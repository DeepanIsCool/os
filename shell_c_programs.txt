# Linux Shell Commands, C Programs and Algorithms

## 1. Even or Odd

### Shell Script
```bash
#!/bin/bash
echo "Enter a number:"
read num
if [ $((num % 2)) -eq 0 ]; then
    echo "$num is Even"
else
    echo "$num is Odd"
fi
```

### C Code
```c
#include <stdio.h>

int main() {
    int num;
    printf("Enter a number: ");
    scanf("%d", &num);
    
    if (num % 2 == 0)
        printf("%d is Even\n", num);
    else
        printf("%d is Odd\n", num);
    
    return 0;
}
```

### Algorithm
- Read a number from the user
- Divide the number by 2 and find the remainder
- If remainder is zero, the number is even
- Otherwise, the number is odd
- Display the result

---

## 2. Leap Year

### Shell Script
```bash
#!/bin/bash
echo "Enter a year:"
read year
if [ $((year % 400)) -eq 0 ]; then
    echo "$year is a Leap Year"
elif [ $((year % 100)) -eq 0 ]; then
    echo "$year is not a Leap Year"
elif [ $((year % 4)) -eq 0 ]; then
    echo "$year is a Leap Year"
else
    echo "$year is not a Leap Year"
fi
```

### C Code
```c
#include <stdio.h>

int main() {
    int year;
    printf("Enter a year: ");
    scanf("%d", &year);
    
    if (year % 400 == 0)
        printf("%d is a Leap Year\n", year);
    else if (year % 100 == 0)
        printf("%d is not a Leap Year\n", year);
    else if (year % 4 == 0)
        printf("%d is a Leap Year\n", year);
    else
        printf("%d is not a Leap Year\n", year);
    
    return 0;
}
```

### Algorithm
- Read a year from the user
- Check if year is divisible by 400, if yes then it is a leap year
- Else check if year is divisible by 100, if yes then it is not a leap year
- Else check if year is divisible by 4, if yes then it is a leap year
- Otherwise it is not a leap year
- Display the result

---

## 3. Factorial

### Shell Script
```bash
#!/bin/bash
echo "Enter a number:"
read num
fact=1
i=1
while [ $i -le $num ]; do
    fact=$((fact * i))
    i=$((i + 1))
done
echo "Factorial of $num is $fact"
```

### C Code
```c
#include <stdio.h>

int main() {
    int num, i;
    long long fact = 1;
    
    printf("Enter a number: ");
    scanf("%d", &num);
    
    for (i = 1; i <= num; i++) {
        fact *= i;
    }
    
    printf("Factorial of %d is %lld\n", num, fact);
    return 0;
}
```

### Algorithm
- Read a number from the user
- Initialize factorial variable to 1
- Initialize counter variable to 1
- Run a loop from 1 to the number
- In each iteration, multiply factorial by counter value
- Increment counter
- After loop ends, display the factorial value

---

## 4. Swap Two Integers

### Shell Script
```bash
#!/bin/bash
echo "Enter first number:"
read a
echo "Enter second number:"
read b
echo "Before swap: a=$a, b=$b"
temp=$a
a=$b
b=$temp
echo "After swap: a=$a, b=$b"
```

### C Code
```c
#include <stdio.h>

int main() {
    int a, b, temp;
    
    printf("Enter first number: ");
    scanf("%d", &a);
    printf("Enter second number: ");
    scanf("%d", &b);
    
    printf("Before swap: a=%d, b=%d\n", a, b);
    
    temp = a;
    a = b;
    b = temp;
    
    printf("After swap: a=%d, b=%d\n", a, b);
    return 0;
}
```

### Algorithm
- Read two numbers from the user into variables a and b
- Display values before swapping
- Store value of a in a temporary variable
- Assign value of b to a
- Assign value of temporary variable to b
- Display values after swapping

---

## 5. Basic Arithmetic Operations

### Shell Script
```bash
#!/bin/bash
echo "Enter first number:"
read a
echo "Enter second number:"
read b
echo "Addition: $((a + b))"
echo "Subtraction: $((a - b))"
echo "Multiplication: $((a * b))"
if [ $b -ne 0 ]; then
    echo "Division: $((a / b))"
else
    echo "Division: Cannot divide by zero"
fi
```

### C Code
```c
#include <stdio.h>

int main() {
    float a, b;
    
    printf("Enter first number: ");
    scanf("%f", &a);
    printf("Enter second number: ");
    scanf("%f", &b);
    
    printf("Addition: %.2f\n", a + b);
    printf("Subtraction: %.2f\n", a - b);
    printf("Multiplication: %.2f\n", a * b);
    
    if (b != 0)
        printf("Division: %.2f\n", a / b);
    else
        printf("Division: Cannot divide by zero\n");
    
    return 0;
}
```

### Algorithm
- Read two numbers from the user
- Perform addition by adding the two numbers and display result
- Perform subtraction by subtracting second from first and display result
- Perform multiplication by multiplying the two numbers and display result
- Check if second number is not zero
- If not zero, perform division by dividing first by second and display result
- If zero, display error message for division by zero

---

## 6. Multiplication Table

### Shell Script
```bash
#!/bin/bash
echo "Enter a number:"
read num
echo "Multiplication table of $num:"
for i in {1..10}; do
    echo "$num x $i = $((num * i))"
done
```

### C Code
```c
#include <stdio.h>

int main() {
    int num, i;
    
    printf("Enter a number: ");
    scanf("%d", &num);
    
    printf("Multiplication table of %d:\n", num);
    for (i = 1; i <= 10; i++) {
        printf("%d x %d = %d\n", num, i, num * i);
    }
    
    return 0;
}
```

### Algorithm
- Read a number from the user
- Initialize counter variable to 1
- Run a loop from 1 to 10
- In each iteration, multiply the number by counter value
- Display the multiplication expression and result
- Increment counter
- Continue until counter reaches 10

---

## 7. File Existence Check

### Shell Script
```bash
#!/bin/bash
echo "Enter filename:"
read filename
if [ -e "$filename" ]; then
    echo "File '$filename' exists"
    if [ -f "$filename" ]; then
        echo "It is a regular file"
    elif [ -d "$filename" ]; then
        echo "It is a directory"
    fi
else
    echo "File '$filename' does not exist"
fi
```

### C Code
```c
#include <stdio.h>

int main() {
    char filename[100];
    FILE *file;
    
    printf("Enter filename: ");
    scanf("%s", filename);
    
    file = fopen(filename, "r");
    
    if (file != NULL) {
        printf("File '%s' exists\n", filename);
        fclose(file);
    } else {
        printf("File '%s' does not exist\n", filename);
    }
    
    return 0;
}
```

### Algorithm
- Read filename from the user
- Attempt to open the file in read mode
- If file pointer is not null, file exists
- Display message that file exists
- Close the file
- If file pointer is null, file does not exist
- Display message that file does not exist

---

## 8. Palindrome Check

### Shell Script
```bash
#!/bin/bash
echo "Enter a number or string:"
read input
reversed=$(echo "$input" | rev)
if [ "$input" = "$reversed" ]; then
    echo "'$input' is a Palindrome"
else
    echo "'$input' is not a Palindrome"
fi
```

### C Code
```c
#include <stdio.h>
#include <string.h>

int main() {
    char str[100], rev[100];
    int i, j, len;
    
    printf("Enter a string: ");
    scanf("%s", str);
    
    len = strlen(str);
    
    for (i = len - 1, j = 0; i >= 0; i--, j++) {
        rev[j] = str[i];
    }
    rev[j] = '\0';
    
    if (strcmp(str, rev) == 0)
        printf("'%s' is a Palindrome\n", str);
    else
        printf("'%s' is not a Palindrome\n", str);
    
    return 0;
}
```

### Algorithm
- Read a string or number from the user
- Find the length of the input
- Create a new string to store reversed version
- Start from last character of original string
- Copy each character to the beginning of reversed string
- Continue until all characters are copied
- Compare original string with reversed string
- If both are equal, input is a palindrome
- Otherwise, input is not a palindrome
- Display the result

---

## 9. Sum of Digits

### Shell Script
```bash
#!/bin/bash
echo "Enter a number:"
read num
sum=0
temp=$num
while [ $temp -gt 0 ]; do
    digit=$((temp % 10))
    sum=$((sum + digit))
    temp=$((temp / 10))
done
echo "Sum of digits of $num is $sum"
```

### C Code
```c
#include <stdio.h>

int main() {
    int num, sum = 0, digit, temp;
    
    printf("Enter a number: ");
    scanf("%d", &num);
    
    temp = num;
    
    while (temp > 0) {
        digit = temp % 10;
        sum += digit;
        temp /= 10;
    }
    
    printf("Sum of digits of %d is %d\n", num, sum);
    return 0;
}
```

### Algorithm
- Read a number from the user
- Initialize sum variable to zero
- Store the number in a temporary variable
- While temporary variable is greater than zero, extract last digit using modulo 10 operation
- Add the digit to sum
- Remove last digit by dividing temporary variable by 10
- Continue loop until all digits are processed
- Display the sum of digits

---

## 10. Count Words in a File

### Shell Script
```bash
#!/bin/bash
echo "Enter filename:"
read filename
if [ -f "$filename" ]; then
    words=$(wc -w < "$filename")
    echo "Number of words in '$filename': $words"
else
    echo "File '$filename' does not exist"
fi
```

### C Code
```c
#include <stdio.h>
#include <ctype.h>

int main() {
    char filename[100];
    FILE *file;
    char ch;
    int words = 0, inWord = 0;
    
    printf("Enter filename: ");
    scanf("%s", filename);
    
    file = fopen(filename, "r");
    
    if (file == NULL) {
        printf("File '%s' does not exist\n", filename);
        return 1;
    }
    
    while ((ch = fgetc(file)) != EOF) {
        if (isspace(ch)) {
            inWord = 0;
        } else if (inWord == 0) {
            inWord = 1;
            words++;
        }
    }
    
    fclose(file);
    printf("Number of words in '%s': %d\n", filename, words);
    return 0;
}
```

### Algorithm
- Read filename from the user
- Attempt to open the file in read mode
- If file does not exist, display error message and exit
- Initialize word counter to zero
- Initialize flag variable to track if currently inside a word
- Read characters from file one by one until end of file
- If character is a space, tab, or newline, set flag to not in word
- If character is not a space and flag indicates not in word, increment word counter and set flag to in word
- Continue until end of file is reached
- Close the file
- Display the total word count

---

## 11. Copy File Content Without cp Command

### Shell Script
```bash
#!/bin/bash
echo "Enter source filename:"
read source
echo "Enter destination filename:"
read dest

if [ ! -f "$source" ]; then
    echo "Source file does not exist"
    exit 1
fi

while IFS= read -r line; do
    echo "$line" >> "$dest"
done < "$source"

echo "File copied successfully from '$source' to '$dest'"
```

### C Code
```c
#include <stdio.h>

int main() {
    char source[100], dest[100];
    FILE *src, *dst;
    char ch;
    
    printf("Enter source filename: ");
    scanf("%s", source);
    printf("Enter destination filename: ");
    scanf("%s", dest);
    
    src = fopen(source, "r");
    if (src == NULL) {
        printf("Cannot open source file '%s'\n", source);
        return 1;
    }
    
    dst = fopen(dest, "w");
    if (dst == NULL) {
        printf("Cannot create destination file '%s'\n", dest);
        fclose(src);
        return 1;
    }
    
    while ((ch = fgetc(src)) != EOF) {
        fputc(ch, dst);
    }
    
    printf("File copied successfully from '%s' to '%s'\n", source, dest);
    
    fclose(src);
    fclose(dst);
    
    return 0;
}
```

### Algorithm
- Read source filename from the user
- Read destination filename from the user
- Open source file in read mode
- If source file cannot be opened, display error message and exit
- Open destination file in write mode
- If destination file cannot be created, close source file and exit
- Read characters from source file one by one until end of file
- Write each character to destination file
- Continue until all characters are copied
- Close both source and destination files
- Display success message

---

## 12. Move File from One Directory to Another Without mv Command

### Shell Script
```bash
#!/bin/bash
echo "Enter source file path:"
read source
echo "Enter destination directory path:"
read destdir

if [ ! -f "$source" ]; then
    echo "Source file does not exist"
    exit 1
fi

if [ ! -d "$destdir" ]; then
    echo "Destination directory does not exist"
    exit 1
fi

filename=$(basename "$source")
destination="$destdir/$filename"

while IFS= read -r line; do
    echo "$line" >> "$destination"
done < "$source"

rm "$source"

echo "File moved successfully from '$source' to '$destination'"
```

### C Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

int main() {
    char source[200], destdir[200], dest[300];
    FILE *src, *dst;
    char ch;
    char *filename;
    
    printf("Enter source file path: ");
    scanf("%s", source);
    printf("Enter destination directory path: ");
    scanf("%s", destdir);
    
    src = fopen(source, "r");
    if (src == NULL) {
        printf("Cannot open source file '%s'\n", source);
        return 1;
    }
    
    // Extract filename from source path
    filename = strrchr(source, '/');
    if (filename == NULL)
        filename = source;
    else
        filename++;
    
    // Create destination path
    sprintf(dest, "%s/%s", destdir, filename);
    
    dst = fopen(dest, "w");
    if (dst == NULL) {
        printf("Cannot create file in destination directory\n");
        fclose(src);
        return 1;
    }
    
    // Copy content
    while ((ch = fgetc(src)) != EOF) {
        fputc(ch, dst);
    }
    
    fclose(src);
    fclose(dst);
    
    // Delete source file
    if (remove(source) == 0)
        printf("File moved successfully from '%s' to '%s'\n", source, dest);
    else
        printf("Error deleting source file\n");
    
    return 0;
}
```

### Algorithm
- Read source file path from the user
- Read destination directory path from the user
- Check if source file exists, if not display error and exit
- Check if destination directory exists, if not display error and exit
- Extract filename from the source path
- Construct destination file path by combining destination directory and filename
- Open source file in read mode
- If source file cannot be opened, display error and exit
- Open destination file in write mode
- If destination file cannot be created, close source and exit
- Read characters from source file one by one until end of file
- Write each character to destination file
- Close both files
- Delete the source file using remove function
- Display success or error message

---

## 13. Process Creation Using fork()

### Shell Script
```bash
#!/bin/bash
echo "Parent Process: PID = $"
echo "Creating child process..."

# Shell doesn't have fork, but we can use background process
(
    echo "Child Process: PID = $, Parent PID = $PPID"
    echo "Child process executing..."
    sleep 2
    echo "Child process completed"
) &

child_pid=$!
echo "Parent Process: Created child with PID = $child_pid"
wait $child_pid
echo "Parent Process: Child has terminated"
echo "Parent process completed"
```

### C Code
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid;
    
    printf("Parent Process: PID = %d\n", getpid());
    printf("Creating child process...\n");
    
    pid = fork();
    
    if (pid < 0) {
        printf("Fork failed!\n");
        return 1;
    }
    else if (pid == 0) {
        // Child process
        printf("\nChild Process: PID = %d, Parent PID = %d\n", 
               getpid(), getppid());
        printf("Child process executing...\n");
        sleep(2);
        printf("Child process completed\n");
    }
    else {
        // Parent process
        printf("Parent Process: Created child with PID = %d\n", pid);
        wait(NULL);
        printf("Parent Process: Child has terminated\n");
        printf("Parent process completed\n");
    }
    
    return 0;
}
```

### Algorithm
- Display parent process ID
- Call fork system call to create a new process
- Fork returns process ID of child to parent and zero to child
- If fork returns negative value, process creation failed, display error and exit
- If fork returns zero, currently executing in child process
- In child process, display child process ID and parent process ID
- Execute child process tasks
- Display child completion message
- If fork returns positive value, currently executing in parent process
- In parent process, display the child process ID that was created
- Wait for child process to complete using wait system call
- After child terminates, display termination message
- Continue with parent process tasks
- Display parent completion message

---

## 14. Multiple Child Processes Using fork()

### C Code
```c
#include <stdio.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/wait.h>

int main() {
    pid_t pid;
    int i, n;
    
    printf("Enter number of child processes to create: ");
    scanf("%d", &n);
    
    printf("\nParent Process: PID = %d\n", getpid());
    
    for (i = 0; i < n; i++) {
        pid = fork();
        
        if (pid < 0) {
            printf("Fork failed!\n");
            return 1;
        }
        else if (pid == 0) {
            // Child process
            printf("Child %d: PID = %d, Parent PID = %d\n", 
                   i + 1, getpid(), getppid());
            sleep(1);
            printf("Child %d completed\n", i + 1);
            return 0; // Child exits
        }
        else {
            // Parent process
            printf("Parent created Child %d with PID = %d\n", i + 1, pid);
        }
    }
    
    // Parent waits for all children
    for (i = 0; i < n; i++) {
        wait(NULL);
        printf("Parent: Child process %d terminated\n", i + 1);
    }
    
    printf("\nParent process completed\n");
    return 0;
}
```

### Algorithm
- Read number of child processes to create from user
- Display parent process ID
- Initialize loop counter to zero
- Run loop for specified number of times
- In each iteration, call fork to create child process
- If fork fails, display error and exit
- If fork returns zero, executing in child process
- In child process, display child number, process ID, and parent ID
- Execute child tasks and exit child process
- If fork returns positive value, executing in parent process
- In parent, display child process ID that was created
- Continue loop to create remaining children
- After all children are created, parent waits for each child
- Run another loop to wait for all children using wait system call
- Display message when each child terminates
- After all children complete, display parent completion message

---

## 15. Schedule Shutdown in X Minutes

### Shell Script
```bash
#!/bin/bash
echo "Enter minutes until shutdown:"
read minutes

if [ $minutes -le 0 ]; then
    echo "Invalid time. Please enter a positive number."
    exit 1
fi

echo "System will shutdown in $minutes minute(s)"
echo "To cancel, use: shutdown -c"

# Schedule shutdown
shutdown -h +$minutes "System is shutting down in $minutes minutes"

# Alternative: using sleep and shutdown now
# sleep $((minutes * 60))
# shutdown -h now
```

### C Code
```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    int minutes;
    char command[200];
    
    printf("Enter minutes until shutdown: ");
    scanf("%d", &minutes);
    
    if (minutes <= 0) {
        printf("Invalid time. Please enter a positive number.\n");
        return 1;
    }
    
    printf("System will shutdown in %d minute(s)\n", minutes);
    printf("To cancel, use: shutdown -c\n");
    
    // Method 1: Using shutdown command with time
    sprintf(command, "shutdown -h +%d \"System shutting down in %d minutes\"", 
            minutes, minutes);
    system(command);
    
    // Method 2: Sleep then shutdown (alternative)
    /*
    printf("Waiting for %d minute(s)...\n", minutes);
    sleep(minutes * 60);
    system("shutdown -h now");
    */
    
    return 0;
}
```

### Algorithm
- Read number of minutes from the user
- Validate that minutes is a positive number
- If invalid, display error message and exit
- Display message showing scheduled shutdown time
- Display information about canceling the shutdown
- Construct shutdown command with specified minutes
- Execute the shutdown command using system call
- Alternative approach: use sleep function to wait for specified minutes converted to seconds
- After sleep completes, execute immediate shutdown command
- Display confirmation message

---

## 16. Display Contents of a Directory

### Shell Script
```bash
#!/bin/bash
echo "Enter directory path (or . for current):"
read dirpath

if [ ! -d "$dirpath" ]; then
    echo "Directory '$dirpath' does not exist"
    exit 1
fi

echo "Contents of directory '$dirpath':"
echo "================================"

for item in "$dirpath"/*; do
    if [ -f "$item" ]; then
        echo "[FILE] $(basename "$item")"
    elif [ -d "$item" ]; then
        echo "[DIR]  $(basename "$item")"
    fi
done

# Alternative: Simple ls
# ls -l "$dirpath"
```

### C Code
```c
#include <stdio.h>
#include <dirent.h>
#include <sys/stat.h>
#include <string.h>

int main() {
    char dirpath[200], fullpath[300];
    DIR *dir;
    struct dirent *entry;
    struct stat fileStat;
    
    printf("Enter directory path (or . for current): ");
    scanf("%s", dirpath);
    
    dir = opendir(dirpath);
    
    if (dir == NULL) {
        printf("Cannot open directory '%s'\n", dirpath);
        return 1;
    }
    
    printf("\nContents of directory '%s':\n", dirpath);
    printf("================================\n");
    
    while ((entry = readdir(dir)) != NULL) {
        // Skip . and ..
        if (strcmp(entry->d_name, ".") == 0 || 
            strcmp(entry->d_name, "..") == 0)
            continue;
        
        // Create full path for stat
        sprintf(fullpath, "%s/%s", dirpath, entry->d_name);
        
        if (stat(fullpath, &fileStat) == 0) {
            if (S_ISDIR(fileStat.st_mode))
                printf("[DIR]  %s\n", entry->d_name);
            else if (S_ISREG(fileStat.st_mode))
                printf("[FILE] %s\n", entry->d_name);
            else
                printf("[OTHER] %s\n", entry->d_name);
        }
    }
    
    closedir(dir);
    return 0;
}
```

### Algorithm
- Read directory path from the user
- If user enters dot, use current directory
- Attempt to open the directory using opendir function
- If directory cannot be opened, display error message and exit
- Display header showing directory path
- Read directory entries one by one using readdir function
- For each entry, skip the special entries dot and dot-dot
- Construct full path by combining directory path and entry name
- Use stat function to get information about the entry
- Check if entry is a directory using file mode flags
- If directory, display with DIR label
- Check if entry is a regular file using file mode flags
- If regular file, display with FILE label
- For other types, display with OTHER label
- Continue until all entries are read
- Close the directory using closedir function

---

## 17. Display Directory Contents with Details

### C Code
```c
#include <stdio.h>
#include <dirent.h>
#include <sys/stat.h>
#include <string.h>
#include <time.h>
#include <pwd.h>
#include <grp.h>

int main() {
    char dirpath[200], fullpath[300];
    DIR *dir;
    struct dirent *entry;
    struct stat fileStat;
    
    printf("Enter directory path (or . for current): ");
    scanf("%s", dirpath);
    
    dir = opendir(dirpath);
    
    if (dir == NULL) {
        printf("Cannot open directory '%s'\n", dirpath);
        return 1;
    }
    
    printf("\nDetailed contents of directory '%s':\n", dirpath);
    printf("Type\tSize(B)\t\tName\n");
    printf("================================================\n");
    
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || 
            strcmp(entry->d_name, "..") == 0)
            continue;
        
        sprintf(fullpath, "%s/%s", dirpath, entry->d_name);
        
        if (stat(fullpath, &fileStat) == 0) {
            if (S_ISDIR(fileStat.st_mode))
                printf("DIR\t%-10s\t%s\n", "<DIR>", entry->d_name);
            else if (S_ISREG(fileStat.st_mode))
                printf("FILE\t%-10ld\t%s\n", fileStat.st_size, entry->d_name);
        }
    }
    
    closedir(dir);
    return 0;
}
```

### Algorithm
- Read directory path from the user
- Open the directory for reading
- If directory cannot be opened, display error and exit
- Display header with column names for type, size, and name
- Read each directory entry in a loop
- Skip the dot and dot-dot entries
- Create full path for each entry
- Get file statistics using stat system call
- Check if entry is a directory
- If directory, display type as DIR and size as directory indicator
- Check if entry is a regular file
- If file, display type as FILE and actual file size in bytes
- Display the entry name
- Continue until all entries are processed
- Close the directory
- Exit program