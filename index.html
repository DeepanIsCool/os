<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Operating Systems - Programs and Algorithms</title>
</head>
<body>

<h1>Operating Systems - Programs and Algorithms</h1>

<h2>Table of Contents</h2>
<ul>
    <li><a href="#cpu-scheduling">CPU Scheduling Algorithms</a>
        <ul>
            <li><a href="#fcfs">FCFS (First Come First Serve)</a></li>
            <li><a href="#sjf">SJF (Shortest Job First)</a></li>
            <li><a href="#priority">Priority Scheduling (Non-Preemptive)</a></li>
            <li><a href="#round-robin">Round Robin</a></li>
        </ul>
    </li>
    <li><a href="#process-sync">Process Synchronization</a>
        <ul>
            <li><a href="#bankers">Banker's Algorithm</a></li>
            <li><a href="#dining">Dining Philosophers Problem</a></li>
            <li><a href="#producer-consumer">Producer-Consumer Problem</a></li>
        </ul>
    </li>
    <li><a href="#disk-scheduling">Disk Scheduling Algorithms</a>
        <ul>
            <li><a href="#disk-fcfs">FCFS</a></li>
            <li><a href="#sstf">SSTF (Shortest Seek Time First)</a></li>
            <li><a href="#scan">SCAN</a></li>
            <li><a href="#look">LOOK</a></li>
            <li><a href="#cscan">C-SCAN</a></li>
            <li><a href="#clook">C-LOOK</a></li>
        </ul>
    </li>
    <li><a href="#shell-programs">Shell Scripts and C Programs</a></li>
</ul>

<hr>

<h2 id="cpu-scheduling">CPU Scheduling Algorithms</h2>

<h3 id="fcfs">1. FCFS (First Come First Serve)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int n, i;
    int bt[20], wt[20], tat[20], ct[20];
    float avg_wt = 0, avg_tat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &amp;n);

    printf("Enter burst times:\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d: ", i + 1);
        scanf("%d", &amp;bt[i]);
    }

    wt[0] = 0;
    ct[0] = bt[0];
    tat[0] = ct[0];

    for (i = 1; i &lt; n; i++) {
        wt[i] = wt[i - 1] + bt[i - 1];
        ct[i] = ct[i - 1] + bt[i];
        tat[i] = wt[i] + bt[i];
    }

    printf("\nProcess\tBT\tWT\tTAT\tCT\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\n", i + 1, bt[i], wt[i], tat[i], ct[i]);
        avg_wt += wt[i];
        avg_tat += tat[i];
    }

    printf("\nAverage Waiting Time: %.2f", avg_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", avg_tat / n);

    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read the number of processes from the user</li>
    <li>Read burst time for each process</li>
    <li>Set waiting time of first process as zero</li>
    <li>Calculate completion time of first process as its burst time</li>
    <li>Calculate turnaround time of first process as its completion time</li>
    <li>For each subsequent process, calculate waiting time as sum of previous waiting time and previous burst time</li>
    <li>Calculate completion time as sum of previous completion time and current burst time</li>
    <li>Calculate turnaround time as sum of waiting time and burst time</li>
    <li>Display process details with burst time, waiting time, turnaround time, and completion time</li>
</ol>

<hr>

<h3 id="sjf">2. SJF (Shortest Job First)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int n, i, j;
    int bt[20], p[20], wt[20], tat[20], ct[20];
    float avg_wt = 0, avg_tat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &amp;n);

    printf("Enter burst times:\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d: ", i + 1);
        scanf("%d", &amp;bt[i]);
        p[i] = i + 1;
    }

    // Sort by burst time (ascending)
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (bt[j] &gt; bt[j + 1]) {
                int temp = bt[j];  bt[j] = bt[j + 1];  bt[j + 1] = temp;
                temp = p[j];       p[j] = p[j + 1];   p[j + 1] = temp;
            }
        }
    }

    wt[0] = 0;
    ct[0] = bt[0];
    tat[0] = ct[0];

    for (i = 1; i &lt; n; i++) {
        wt[i] = wt[i - 1] + bt[i - 1];
        ct[i] = ct[i - 1] + bt[i];
        tat[i] = wt[i] + bt[i];
    }

    printf("\nProcess\tBT\tWT\tTAT\tCT\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\n", p[i], bt[i], wt[i], tat[i], ct[i]);
        avg_wt += wt[i];
        avg_tat += tat[i];
    }

    printf("\nAverage Waiting Time: %.2f", avg_wt / n);
    printf("Average Turnaround Time: %.2f\n", avg_tat / n);

    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read the number of processes from the user</li>
    <li>Read burst time for each process and assign process IDs</li>
    <li>Sort processes by burst time in ascending order using bubble sort</li>
    <li>Keep track of original process IDs during sorting</li>
    <li>Set waiting time of first process (shortest burst time) as zero</li>
    <li>Calculate completion time of first process as its burst time</li>
    <li>For each subsequent process, calculate waiting time, completion time, and turnaround time</li>
    <li>Display process details in order of execution</li>
    <li>Calculate and display average waiting time and turnaround time</li>
</ol>

<hr>

<h3 id="priority">3. Priority Scheduling (Non-Preemptive)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int n, i, completed = 0, t = 0;
    int bt[20], at[20], pr[20], p[20];
    int wt[20], tat[20], ct[20], done[20];
    float avg_wt = 0, avg_tat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &amp;n);

    for (i = 0; i &lt; n; i++) {
        printf("Arrival time of P%d: ", i + 1);
        scanf("%d", &amp;at[i]);
        printf("Burst time of P%d: ", i + 1);
        scanf("%d", &amp;bt[i]);
        printf("Priority of P%d (lower -&gt; higher): ", i + 1);
        scanf("%d", &amp;pr[i]);
        p[i] = i + 1;
        done[i] = 0;
    }

    while (completed &lt; n) {
        int idx = -1;
        int best_pr = 2147483647;

        for (i = 0; i &lt; n; i++) {
            if (!done[i] &amp;&amp; at[i] &lt;= t) {
                if (pr[i] &lt; best_pr) {
                    best_pr = pr[i];
                    idx = i;
                } else if (pr[i] == best_pr) {
                    if (at[i] &lt; at[idx]) idx = i;
                    else if (at[i] == at[idx] &amp;&amp; p[i] &lt; p[idx]) idx = i;
                }
            }
        }

        if (idx == -1) {
            t++;
            continue;
        }

        /* execute process idx */
        t += bt[idx];
        ct[idx] = t;
        tat[idx] = ct[idx] - at[idx];
        wt[idx] = tat[idx] - bt[idx];
        done[idx] = 1;
        completed++;
    }

    printf("\nProcess\tAT\tBT\tPR\tCT\tTAT\tWT\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\t%d\t%d\n",
               p[i], at[i], bt[i], pr[i], ct[i], tat[i], wt[i]);
        avg_wt += wt[i];
        avg_tat += tat[i];
    }

    printf("\nAverage Waiting Time: %.2f", avg_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", avg_tat / n);

    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of processes, arrival time, burst time, and priority for each process</li>
    <li>Initialize all processes as not done</li>
    <li>While not all processes are completed, find the process with highest priority (lowest priority number) that has arrived</li>
    <li>If multiple processes have same priority, select based on arrival time or process ID</li>
    <li>If no process has arrived, increment time</li>
    <li>Execute the selected process completely</li>
    <li>Calculate completion time, turnaround time, and waiting time</li>
    <li>Mark process as done and increment completed counter</li>
    <li>Display process details and average times</li>
</ol>

<hr>

<h3 id="round-robin">4. Round Robin Scheduling</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int n, i, tq;
    int bt[20], at[20], rem[20], wt[20], tat[20], ct[20], p[20];
    int t = 0, completed = 0;
    float avg_wt = 0, avg_tat = 0;

    printf("Enter number of processes: ");
    scanf("%d", &amp;n);

    for (i = 0; i &lt; n; i++) {
        printf("Arrival time of P%d: ", i + 1);
        scanf("%d", &amp;at[i]);
        printf("Burst time of P%d: ", i + 1);
        scanf("%d", &amp;bt[i]);
        rem[i] = bt[i];
        p[i] = i + 1;
    }

    printf("Enter time quantum: ");
    scanf("%d", &amp;tq);

    while (completed &lt; n) {
        int done = 1;

        for (i = 0; i &lt; n; i++) {
            if (at[i] &lt;= t &amp;&amp; rem[i] &gt; 0) {
                done = 0;

                if (rem[i] &gt; tq) {
                    t += tq;
                    rem[i] -= tq;
                } else {
                    t += rem[i];
                    ct[i] = t;
                    rem[i] = 0;
                    completed++;
                }
            }
        }

        if (done) t++;
    }

    for (i = 0; i &lt; n; i++) {
        tat[i] = ct[i] - at[i];
        wt[i] = tat[i] - bt[i];
        avg_wt += wt[i];
        avg_tat += tat[i];
    }

    printf("\nProcess\tAT\tBT\tCT\tTAT\tWT\n");
    for (i = 0; i &lt; n; i++) {
        printf("P%d\t%d\t%d\t%d\t%d\t%d\n",
               p[i], at[i], bt[i], ct[i], tat[i], wt[i]);
    }

    printf("\nAverage Waiting Time: %.2f", avg_wt / n);
    printf("\nAverage Turnaround Time: %.2f\n", avg_tat / n);

    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of processes, arrival time, and burst time for each process</li>
    <li>Read time quantum value</li>
    <li>Initialize remaining time for each process equal to burst time</li>
    <li>While not all processes are completed, iterate through all processes</li>
    <li>For each process that has arrived and has remaining time, execute it for time quantum or remaining time (whichever is smaller)</li>
    <li>If process completes, record completion time and increment completed counter</li>
    <li>If no process is ready, increment time</li>
    <li>Calculate turnaround time and waiting time for each process</li>
    <li>Display process details and average times</li>
</ol>

<hr>

<h2 id="process-sync">Process Synchronization</h2>

<h3 id="bankers">1. Banker's Algorithm</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int P, R;
    printf("Enter number of processes: ");
    scanf("%d", &amp;P);

    printf("Enter number of resources: ");
    scanf("%d", &amp;R);

    int allocation[10][10], max[10][10], need[10][10], available[10];
    int finished[10], safeSeq[10];

    int i, j;

    printf("Enter Allocation matrix:\n");
    for (i = 0; i &lt; P; i++) {
        for (j = 0; j &lt; R; j++) {
            scanf("%d", &amp;allocation[i][j]);
        }
    }

    printf("Enter Max matrix:\n");
    for (i = 0; i &lt; P; i++) {
        for (j = 0; j &lt; R; j++) {
            scanf("%d", &amp;max[i][j]);
        }
    }

    printf("Enter Available resources:\n");
    for (i = 0; i &lt; R; i++) {
        scanf("%d", &amp;available[i]);
    }

    // Calculate Need = Max - Allocation
    for (i = 0; i &lt; P; i++) {
        for (j = 0; j &lt; R; j++) {
            need[i][j] = max[i][j] - allocation[i][j];
        }
        finished[i] = 0;
    }

    int count = 0;

    while (count &lt; P) {
        int found = 0;

        for (i = 0; i &lt; P; i++) {
            if (finished[i] == 0) {
                int canAllocate = 1;

                for (j = 0; j &lt; R; j++) {
                    if (need[i][j] &gt; available[j]) {
                        canAllocate = 0;
                        break;
                    }
                }

                if (canAllocate) {
                    for (j = 0; j &lt; R; j++)
                        available[j] += allocation[i][j];

                    safeSeq[count++] = i;
                    finished[i] = 1;
                    found = 1;
                }
            }
        }

        if (found == 0) {
            printf("System is not in a safe state.\n");
            return 0;
        }
    }

    printf("System is in a safe state.\nSafe sequence: ");
    for (i = 0; i &lt; P; i++)
        printf("P%d ", safeSeq[i]);
    printf("\n");

    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of processes and resources</li>
    <li>Read allocation matrix (current allocation for each process)</li>
    <li>Read max matrix (maximum demand for each process)</li>
    <li>Read available resources vector</li>
    <li>Calculate need matrix as Max minus Allocation</li>
    <li>Mark all processes as unfinished</li>
    <li>While not all processes are finished, find a process whose need can be satisfied with available resources</li>
    <li>If found, add its allocated resources to available, mark it as finished, and add to safe sequence</li>
    <li>If no such process is found, system is in unsafe state</li>
    <li>If all processes finish, system is in safe state</li>
    <li>Display the safe sequence</li>
</ol>

<hr>

<h3 id="dining">2. Dining Philosophers Problem</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;pthread.h&gt;
#include &lt;semaphore.h&gt;
#include &lt;unistd.h&gt;

#define N 5  /* number of philosophers */

sem_t chopstick[N];

void *philosopher(void *arg) {
    int id = *(int *)arg;
    for (;;) {
        printf("Philosopher %d is thinking...\n", id);
        sleep(1);

        /* pick up left chopstick */
        sem_wait(&amp;chopstick[id]);

        /* pick up right chopstick */
        sem_wait(&amp;chopstick[(id + 1) % N]);

        printf("Philosopher %d is eating...\n", id);
        sleep(2);

        /* put down left chopstick */
        sem_post(&amp;chopstick[id]);

        /* put down right chopstick */
        sem_post(&amp;chopstick[(id + 1) % N]);

        printf("Philosopher %d finished eating and put down chopsticks.\n", id);
    }
    return NULL;
}

int main(void) {
    pthread_t threads[N];
    int ids[N];

    for (int i = 0; i &lt; N; i++) {
        if (sem_init(&amp;chopstick[i], 0, 1) != 0) {
            perror("sem_init");
            return EXIT_FAILURE;
        }
    }

    for (int i = 0; i &lt; N; i++) {
        ids[i] = i;
        if (pthread_create(&amp;threads[i], NULL, philosopher, &amp;ids[i]) != 0) {
            perror("pthread_create");
            return EXIT_FAILURE;
        }
    }

    for (int i = 0; i &lt; N; i++) {
        pthread_join(threads[i], NULL);
    }

    for (int i = 0; i &lt; N; i++) sem_destroy(&amp;chopstick[i]);

    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Initialize a semaphore for each chopstick with value one</li>
    <li>Create a philosopher thread for each philosopher</li>
    <li>Each philosopher thread runs an infinite loop with thinking and eating phases</li>
    <li>In thinking phase, display that philosopher is thinking and wait for some time</li>
    <li>To eat, philosopher picks up left chopstick by waiting on its semaphore</li>
    <li>Then picks up right chopstick by waiting on the next semaphore</li>
    <li>Display that philosopher is eating and wait for some time</li>
    <li>After eating, put down left chopstick by signaling its semaphore</li>
    <li>Put down right chopstick by signaling the next semaphore</li>
    <li>Display that philosopher finished eating</li>
    <li>Return to thinking phase</li>
    <li>Main thread waits for all philosopher threads to complete</li>
</ol>

<hr>

<h3 id="producer-consumer">3. Producer-Consumer Problem</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;pthread.h&gt;
#include &lt;stdlib.h&gt;
#include &lt;unistd.h&gt;
#include &lt;time.h&gt;

#define BUFFER_SIZE 5

int buffer[BUFFER_SIZE];
int in = 0, out = 0, count = 0;

pthread_mutex_t mutex;
pthread_cond_t not_full;
pthread_cond_t not_empty;

void* producer(void* arg) {
    (void)arg;
    while (1) {
        int item = rand() % 100; // produce an item

        pthread_mutex_lock(&amp;mutex);

        while (count == BUFFER_SIZE) // buffer full
            pthread_cond_wait(&amp;not_full, &amp;mutex);

        buffer[in] = item;
        printf("Produced: %d at index %d\n", item, in);
        in = (in + 1) % BUFFER_SIZE;
        count++;

        pthread_cond_signal(&amp;not_empty); // signal buffer has item
        pthread_mutex_unlock(&amp;mutex);

        sleep(1); // simulate production time
    }
    return NULL;
}

void* consumer(void* arg) {
    (void)arg;
    while (1) {
        pthread_mutex_lock(&amp;mutex);

        while (count == 0) // buffer empty
            pthread_cond_wait(&amp;not_empty, &amp;mutex);

        int item = buffer[out];
        printf("Consumed: %d from index %d\n", item, out);
        out = (out + 1) % BUFFER_SIZE;
        count--;

        pthread_cond_signal(&amp;not_full); // signal buffer has space
        pthread_mutex_unlock(&amp;mutex);

        sleep(1); // simulate consumption time
    }
    return NULL;
}

int main() {
    pthread_t prod, cons;

    srand((unsigned)time(NULL));

    pthread_mutex_init(&amp;mutex, NULL);
    pthread_cond_init(&amp;not_full, NULL);
    pthread_cond_init(&amp;not_empty, NULL);

    if (pthread_create(&amp;prod, NULL, producer, NULL) != 0) {
        perror("Failed to create producer thread");
        return 1;
    }
    if (pthread_create(&amp;cons, NULL, consumer, NULL) != 0) {
        perror("Failed to create consumer thread");
        return 1;
    }

    pthread_join(prod, NULL);
    pthread_join(cons, NULL);

    pthread_mutex_destroy(&amp;mutex);
    pthread_cond_destroy(&amp;not_full);
    pthread_cond_destroy(&amp;not_empty);

    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Initialize a buffer of fixed size with head and tail pointers and count variable</li>
    <li>Initialize a mutex lock for synchronization</li>
    <li>Initialize condition variables for buffer not full and buffer not empty</li>
    <li>Create producer thread that runs indefinitely</li>
    <li>Producer generates a random item</li>
    <li>Lock the mutex</li>
    <li>If buffer is full, wait on not full condition variable</li>
    <li>Add item to buffer at head position</li>
    <li>Increment head pointer circularly and increment count</li>
    <li>Signal not empty condition variable</li>
    <li>Unlock the mutex</li>
    <li>Create consumer thread that runs indefinitely</li>
    <li>Consumer locks the mutex</li>
    <li>If buffer is empty, wait on not empty condition variable</li>
    <li>Remove item from buffer at tail position</li>
    <li>Increment tail pointer circularly and decrement count</li>
    <li>Signal not full condition variable</li>
    <li>Unlock the mutex</li>
</ol>

<hr>

<h2 id="disk-scheduling">Disk Scheduling Algorithms</h2>

<h3 id="disk-fcfs">1. FCFS (First Come First Serve)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int n, head, i, total = 0;
    int req[100];

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    printf("\nFCFS Order: %d ", head);

    for (i = 0; i &lt; n; i++) {
        total += abs(req[i] - head);
        head = req[i];
        printf("-&gt; %d ", head);
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions in order</li>
    <li>Read initial head position</li>
    <li>Start from initial head position</li>
    <li>Service each request in the order they arrived</li>
    <li>For each request, calculate absolute difference from current head position</li>
    <li>Add this difference to total head movement</li>
    <li>Move head to the request position</li>
    <li>Continue until all requests are serviced</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h3 id="sstf">2. SSTF (Shortest Seek Time First)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

int main() {
    int n, head, i, count = 0;
    int req[100], visited[100] = {0};
    int total = 0;

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    printf("\nSSTF Order: %d ", head);

    while (count &lt; n) {
        int min = 9999, index = -1;

        for (i = 0; i &lt; n; i++) {
            if (!visited[i]) {
                int diff = abs(req[i] - head);
                if (diff &lt; min) {
                    min = diff;
                    index = i;
                }
            }
        }

        visited[index] = 1;
        total += abs(req[index] - head);
        head = req[index];

        printf("-&gt; %d ", head);
        count++;
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions</li>
    <li>Read initial head position</li>
    <li>Mark all requests as unvisited</li>
    <li>Start from initial head position</li>
    <li>While there are unvisited requests, find the unvisited request closest to current head position</li>
    <li>Calculate distance for all unvisited requests and select the one with minimum distance</li>
    <li>Mark that request as visited</li>
    <li>Add the distance to total head movement</li>
    <li>Move head to that request position</li>
    <li>Continue until all requests are visited</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h3 id="scan">3. SCAN</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void sort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}


int main() {
    int n, head, disk, i;
    int req[100], left[100], right[100];
    int l = 0, r = 0, total = 0;

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    printf("Enter disk size: ");
    scanf("%d", &amp;disk);

    right[r++] = disk;
    for (i = 0; i &lt; n; i++) {
        if (req[i] &gt;= head) right[r++] = req[i];
        else left[l++] = req[i];
    }

    sort(left, l);
    sort(right, r);

    printf("\nSCAN Order: %d ", head);

    for (i = 0; i &lt; r; i++) {
        total += abs(right[i] - head);
        head = right[i];
        printf("-&gt; %d ", head);
    }

    for (i = l - 1; i &gt;= 0; i--) {
        total += abs(left[i] - head);
        head = left[i];
        printf("-&gt; %d ", head);
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions</li>
    <li>Read initial head position and disk size</li>
    <li>Add disk end position to right array</li>
    <li>Separate requests into left array for positions less than head and right array for positions greater than or equal to head</li>
    <li>Sort both arrays in ascending order</li>
    <li>Start from initial head position</li>
    <li>Service all requests in right array in ascending order including disk end, calculating total head movement</li>
    <li>After reaching disk end, reverse direction</li>
    <li>Service all requests in left array in descending order, calculating total head movement</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h3 id="look">4. LOOK</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void sort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}


int main() {
    int n, head, i;
    int req[100], left[100], right[100];
    int l = 0, r = 0, total = 0;

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    for (i = 0; i &lt; n; i++) {
        if (req[i] &gt;= head) right[r++] = req[i];
        else left[l++] = req[i];
    }

    sort(left, l);
    sort(right, r);

    printf("\nLOOK Order: %d ", head);

    for (i = 0; i &lt; r; i++) {
        total += abs(right[i] - head);
        head = right[i];
        printf("-&gt; %d ", head);
    }

    for (i = l - 1; i &gt;= 0; i--) {
        total += abs(left[i] - head);
        head = left[i];
        printf("-&gt; %d ", head);
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions</li>
    <li>Read initial head position</li>
    <li>Separate requests into left array for positions less than head and right array for positions greater than or equal to head</li>
    <li>Sort both arrays in ascending order</li>
    <li>Start from initial head position</li>
    <li>Service all requests in right array in ascending order, calculating total head movement</li>
    <li>After reaching the last request in right direction, reverse direction</li>
    <li>Service all requests in left array in descending order, calculating total head movement</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h3 id="cscan">5. C-SCAN (Circular SCAN)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void sort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}


int main() {
    int n, head, disk, i;
    int req[100], left[100], right[100];
    int l = 0, r = 0, total = 0;

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    printf("Enter disk size: ");
    scanf("%d", &amp;disk);

    right[r++] = disk;
    left[l++] = 0;

    for (i = 0; i &lt; n; i++) {
        if (req[i] &gt;= head) right[r++] = req[i];
        else left[l++] = req[i];
    }

    sort(left, l);
    sort(right, r);

    printf("\nCSCAN Order: %d ", head);

    for (i = 0; i &lt; r; i++) {
        total += abs(right[i] - head);
        head = right[i];
        printf("-&gt; %d ", head);
    }

    head = 0;

    for (i = 0; i &lt; l; i++) {
        total += abs(left[i] - head);
        head = left[i];
        printf("-&gt; %d ", head);
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions</li>
    <li>Read initial head position and disk size</li>
    <li>Add disk end position to right array and zero to left array</li>
    <li>Separate requests into left array for positions less than head and right array for positions greater than or equal to head</li>
    <li>Sort both left and right arrays in ascending order</li>
    <li>Start from initial head position</li>
    <li>Service all requests in right array in ascending order including disk end, calculating total head movement</li>
    <li>Jump to beginning of disk at position zero</li>
    <li>Service all requests in left array in ascending order, calculating total head movement</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h3 id="clook">6. C-LOOK (Circular LOOK)</h3>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

void sort(int arr[], int n) {
    int i, j, temp;
    for (i = 0; i &lt; n - 1; i++) {
        for (j = 0; j &lt; n - i - 1; j++) {
            if (arr[j] &gt; arr[j + 1]) {
                temp = arr[j];
                arr[j] = arr[j + 1];
                arr[j + 1] = temp;
            }
        }
    }
}


int main() {
    int n, head, i;
    int req[100], left[100], right[100];
    int l = 0, r = 0, total = 0;

    printf("Enter number of requests: ");
    scanf("%d", &amp;n);

    printf("Enter request queue: ");
    for (i = 0; i &lt; n; i++) scanf("%d", &amp;req[i]);

    printf("Enter initial head position: ");
    scanf("%d", &amp;head);

    for (i = 0; i &lt; n; i++) {
        if (req[i] &gt;= head) right[r++] = req[i];
        else left[l++] = req[i];
    }

    sort(left, l);
    sort(right, r);

    printf("\nCLOOK Order: %d ", head);

    for (i = 0; i &lt; r; i++) {
        total += abs(right[i] - head);
        head = right[i];
        printf("-&gt; %d ", head);
    }

    total += abs(head - left[0]);
    head = left[0];

    for (i = 0; i &lt; l; i++) {
        total += abs(left[i] - head);
        head = left[i];
        printf("-&gt; %d ", head);
    }

    printf("\nTotal Head Movement = %d\n", total);
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read number of disk requests from the user</li>
    <li>Read all request positions</li>
    <li>Read initial head position</li>
    <li>Separate requests into left array for positions less than head and right array for positions greater than or equal to head</li>
    <li>Sort both left and right arrays in ascending order</li>
    <li>Start from initial head position</li>
    <li>Service all requests in right array in ascending order, calculating total head movement</li>
    <li>Jump to the smallest request in left array</li>
    <li>Service all requests in left array in ascending order, calculating total head movement</li>
    <li>Display the order of disk head movement</li>
    <li>Display total head movement</li>
</ol>

<hr>

<h2 id="shell-programs">Shell Scripts and C Programs</h2>

<h3>1. Even or Odd</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a number:"
read num
if [ $((num % 2)) -eq 0 ]; then
    echo "$num is Even"
else
    echo "$num is Odd"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int num;
    printf("Enter a number: ");
    scanf("%d", &amp;num);
    
    if (num % 2 == 0)
        printf("%d is Even\n", num);
    else
        printf("%d is Odd\n", num);
    
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a number from the user</li>
    <li>Divide the number by 2 and find the remainder</li>
    <li>If remainder is zero, the number is even</li>
    <li>Otherwise, the number is odd</li>
    <li>Display the result</li>
</ol>

<hr>

<h3>2. Leap Year</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a year:"
read year
if [ $((year % 400)) -eq 0 ]; then
    echo "$year is a Leap Year"
elif [ $((year % 100)) -eq 0 ]; then
    echo "$year is not a Leap Year"
elif [ $((year % 4)) -eq 0 ]; then
    echo "$year is a Leap Year"
else
    echo "$year is not a Leap Year"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int year;
    printf("Enter a year: ");
    scanf("%d", &amp;year);
    
    if (year % 400 == 0)
        printf("%d is a Leap Year\n", year);
    else if (year % 100 == 0)
        printf("%d is not a Leap Year\n", year);
    else if (year % 4 == 0)
        printf("%d is a Leap Year\n", year);
    else
        printf("%d is not a Leap Year\n", year);
    
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a year from the user</li>
    <li>Check if year is divisible by 400, if yes then it is a leap year</li>
    <li>Else check if year is divisible by 100, if yes then it is not a leap year</li>
    <li>Else check if year is divisible by 4, if yes then it is a leap year</li>
    <li>Otherwise it is not a leap year</li>
    <li>Display the result</li>
</ol>

<hr>

<h3>3. Factorial</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a number:"
read num
fact=1
i=1
while [ $i -le $num ]; do
    fact=$((fact * i))
    i=$((i + 1))
done
echo "Factorial of $num is $fact"
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int num, i;
    long long fact = 1;
    
    printf("Enter a number: ");
    scanf("%d", &amp;num);
    
    for (i = 1; i &lt;= num; i++) {
        fact *= i;
    }
    
    printf("Factorial of %d is %lld\n", num, fact);
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a number from the user</li>
    <li>Initialize factorial variable to 1</li>
    <li>Initialize counter variable to 1</li>
    <li>Run a loop from 1 to the number</li>
    <li>In each iteration, multiply factorial by counter value</li>
    <li>Increment counter</li>
    <li>After loop ends, display the factorial value</li>
</ol>

<hr>

<h3>4. Swap Two Integers</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter first number:"
read a
echo "Enter second number:"
read b
echo "Before swap: a=$a, b=$b"
temp=$a
a=$b
b=$temp
echo "After swap: a=$a, b=$b"
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int a, b, temp;
    
    printf("Enter first number: ");
    scanf("%d", &amp;a);
    printf("Enter second number: ");
    scanf("%d", &amp;b);
    
    printf("Before swap: a=%d, b=%d\n", a, b);
    
    temp = a;
    a = b;
    b = temp;
    
    printf("After swap: a=%d, b=%d\n", a, b);
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read two numbers from the user into variables a and b</li>
    <li>Display values before swapping</li>
    <li>Store value of a in a temporary variable</li>
    <li>Assign value of b to a</li>
    <li>Assign value of temporary variable to b</li>
    <li>Display values after swapping</li>
</ol>

<hr>

<h3>5. Basic Arithmetic Operations</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter first number:"
read a
echo "Enter second number:"
read b
echo "Addition: $((a + b))"
echo "Subtraction: $((a - b))"
echo "Multiplication: $((a * b))"
if [ $b -ne 0 ]; then
    echo "Division: $((a / b))"
else
    echo "Division: Cannot divide by zero"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    float a, b;
    
    printf("Enter first number: ");
    scanf("%f", &amp;a);
    printf("Enter second number: ");
    scanf("%f", &amp;b);
    
    printf("Addition: %.2f\n", a + b);
    printf("Subtraction: %.2f\n", a - b);
    printf("Multiplication: %.2f\n", a * b);
    
    if (b != 0)
        printf("Division: %.2f\n", a / b);
    else
        printf("Division: Cannot divide by zero\n");
    
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read two numbers from the user</li>
    <li>Perform addition by adding the two numbers and display result</li>
    <li>Perform subtraction by subtracting second from first and display result</li>
    <li>Perform multiplication by multiplying the two numbers and display result</li>
    <li>Check if second number is not zero</li>
    <li>If not zero, perform division by dividing first by second and display result</li>
    <li>If zero, display error message for division by zero</li>
</ol>

<hr>

<h3>6. Multiplication Table</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a number:"
read num
echo "Multiplication table of $num:"
for i in {1..10}; do
    echo "$num x $i = $((num * i))"
done
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int num, i;
    
    printf("Enter a number: ");
    scanf("%d", &amp;num);
    
    printf("Multiplication table of %d:\n", num);
    for (i = 1; i &lt;= 10; i++) {
        printf("%d x %d = %d\n", num, i, num * i);
    }
    
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a number from the user</li>
    <li>Initialize counter variable to 1</li>
    <li>Run a loop from 1 to 10</li>
    <li>In each iteration, multiply the number by counter value</li>
    <li>Display the multiplication expression and result</li>
    <li>Increment counter</li>
    <li>Continue until counter reaches 10</li>
</ol>

<hr>

<h3>7. File Existence Check</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter filename:"
read filename
if [ -e "$filename" ]; then
    echo "File '$filename' exists"
    if [ -f "$filename" ]; then
        echo "It is a regular file"
    elif [ -d "$filename" ]; then
        echo "It is a directory"
    fi
else
    echo "File '$filename' does not exist"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    char filename[100];
    FILE *file;
    
    printf("Enter filename: ");
    scanf("%s", filename);
    
    file = fopen(filename, "r");
    
    if (file != NULL) {
        printf("File '%s' exists\n", filename);
        fclose(file);
    } else {
        printf("File '%s' does not exist\n", filename);
    }
    
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read filename from the user</li>
    <li>Attempt to open the file in read mode</li>
    <li>If file pointer is not null, file exists</li>
    <li>Display message that file exists</li>
    <li>Close the file</li>
    <li>If file pointer is null, file does not exist</li>
    <li>Display message that file does not exist</li>
</ol>

<hr>

<h3>8. Palindrome Check</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a number or string:"
read input
reversed=$(echo "$input" | rev)
if [ "$input" = "$reversed" ]; then
    echo "'$input' is a Palindrome"
else
    echo "'$input' is not a Palindrome"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;

int main() {
    char str[100], rev[100];
    int i, j, len;
    
    printf("Enter a string: ");
    scanf("%s", str);
    
    len = strlen(str);
    
    for (i = len - 1, j = 0; i &gt;= 0; i--, j++) {
        rev[j] = str[i];
    }
    rev[j] = '\0';
    
    if (strcmp(str, rev) == 0)
        printf("'%s' is a Palindrome\n", str);
    else
        printf("'%s' is not a Palindrome\n", str);
    
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a string or number from the user</li>
    <li>Find the length of the input</li>
    <li>Create a new string to store reversed version</li>
    <li>Start from last character of original string</li>
    <li>Copy each character to the beginning of reversed string</li>
    <li>Continue until all characters are copied</li>
    <li>Compare original string with reversed string</li>
    <li>If both are equal, input is a palindrome</li>
    <li>Otherwise, input is not a palindrome</li>
    <li>Display the result</li>
</ol>

<hr>

<h3>9. Sum of Digits</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter a number:"
read num
sum=0
temp=$num
while [ $temp -gt 0 ]; do
    digit=$((temp % 10))
    sum=$((sum + digit))
    temp=$((temp / 10))
done
echo "Sum of digits of $num is $sum"
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;

int main() {
    int num, sum = 0, digit, temp;
    
    printf("Enter a number: ");
    scanf("%d", &amp;num);
    
    temp = num;
    
    while (temp &gt; 0) {
        digit = temp % 10;
        sum += digit;
        temp /= 10;
    }
    
    printf("Sum of digits of %d is %d\n", num, sum);
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read a number from the user</li>
    <li>Initialize sum variable to zero</li>
    <li>Store the number in a temporary variable</li>
    <li>While temporary variable is greater than zero, extract last digit using modulo 10 operation</li>
    <li>Add the digit to sum</li>
    <li>Remove last digit by dividing temporary variable by 10</li>
    <li>Continue loop until all digits are processed</li>
    <li>Display the sum of digits</li>
</ol>

<hr>

<h3>10. Count Words in a File</h3>

<h4>Shell Script:</h4>
<pre>
#!/bin/bash
echo "Enter filename:"
read filename
if [ -f "$filename" ]; then
    words=$(wc -w &lt; "$filename")
    echo "Number of words in '$filename': $words"
else
    echo "File '$filename' does not exist"
fi
</pre>

<h4>C Program:</h4>
<pre>
#include &lt;stdio.h&gt;
#include &lt;ctype.h&gt;

int main() {
    char filename[100];
    FILE *file;
    char ch;
    int words = 0, inWord = 0;
    
    printf("Enter filename: ");
    scanf("%s", filename);
    
    file = fopen(filename, "r");
    
    if (file == NULL) {
        printf("File '%s' does not exist\n", filename);
        return 1;
    }
    
    while ((ch = fgetc(file)) != EOF) {
        if (isspace(ch)) {
            inWord = 0;
        } else if (inWord == 0) {
            inWord = 1;
            words++;
        }
    }
    
    fclose(file);
    printf("Number of words in '%s': %d\n", filename, words);
    return 0;
}
</pre>

<h4>Algorithm:</h4>
<ol>
    <li>Read filename from the user</li>
    <li>Attempt to open the file in read mode</li>
    <li>If file does not exist, display error message and exit</li>
    <li>Initialize word counter to zero</li>
    <li>Initialize flag variable to track if currently inside a word</li>
    <li>Read characters from file one by one until end of file</li>
    <li>If character is a space, tab, or newline, set flag to not in word</li>
    <li>If character is not a space and flag indicates not in word, increment word counter and set flag to in word</li>
    <li>Continue until end of file is reached</li>
    <li>Close the file</li>
    <li>Display the total word count</li>
</ol>

<hr>

<p><a href="#top">Back to Top</a></p>

<footer>
    <p>Operating Systems - Programs and Algorithms Reference</p>
    <p>All content in plain HTML for terminal browser compatibility</p>
</footer>

</body>
</html>
